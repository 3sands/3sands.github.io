<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://3sands.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://3sands.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-10-12T03:21:31+00:00</updated><id>https://3sands.github.io/feed.xml</id><title type="html">blank</title><subtitle>Poems and thoughts and projects about poetry and programming </subtitle><entry><title type="html">The Quatraits of RxSwift - Part 2</title><link href="https://3sands.github.io/blog/2023/quatraitsPart2/" rel="alternate" type="text/html" title="The Quatraits of RxSwift - Part 2"/><published>2023-10-11T00:00:00+00:00</published><updated>2023-10-11T00:00:00+00:00</updated><id>https://3sands.github.io/blog/2023/quatraitsPart2</id><content type="html" xml:base="https://3sands.github.io/blog/2023/quatraitsPart2/"><![CDATA[<p>In <a href="/blog/2023/quatraitsPart1/">Part One</a> of this series, I provided the mnemonic poems I used to help learn and retain the basics of Reactive programming, specifically <code class="language-plaintext highlighter-rouge">Observable</code>s and one operator (<code class="language-plaintext highlighter-rouge">flatMap</code>) in <code class="language-plaintext highlighter-rouge">RxSwift</code>.</p> <p>Now, Part Two will go over four different <code class="language-plaintext highlighter-rouge">Trait</code>s that an <code class="language-plaintext highlighter-rouge">Observable</code> can be: <code class="language-plaintext highlighter-rouge">Single</code>, <code class="language-plaintext highlighter-rouge">Completable</code>, <code class="language-plaintext highlighter-rouge">Maybe</code>, and <code class="language-plaintext highlighter-rouge">Subject</code>.</p> <h2 id="traits">Traits</h2> <p>A <code class="language-plaintext highlighter-rouge">Trait</code> is an <code class="language-plaintext highlighter-rouge">Observable</code> but with its own specifications and limitations and uses beyond the broader <code class="language-plaintext highlighter-rouge">Observable</code>. These shared <code class="language-plaintext highlighter-rouge">Trait</code>s allow for consistency across Rx implementations (RxJava, RxSwift, RxKotlin, etc.) and enable easier cross-platform communication and guarantees certain properties. <code class="language-plaintext highlighter-rouge">Traits</code> are largely just syntactical sugar and interfaces atop the underlying <code class="language-plaintext highlighter-rouge">Observable</code>.</p> <h3 id="all-the-single-clades">“All The Single Clades”</h3> <p>a Single has one guarantee:<br/> an element or wrong –<br/> if eventS emit, error –<br/> error fore’er long –</p> <h3 id="explanation">Explanation</h3> <p>The base <code class="language-plaintext highlighter-rouge">Observable</code>, as mentioned in part one, may produce multiple elements over its lifetime. A <code class="language-plaintext highlighter-rouge">Single</code>, however, as the name implies, will only ever provide 1 <code class="language-plaintext highlighter-rouge">T</code> element (if it produces an element at all). A <code class="language-plaintext highlighter-rouge">Single</code>, then, combines both its <code class="language-plaintext highlighter-rouge">T</code> element and its <code class="language-plaintext highlighter-rouge">onComplete</code>. A <code class="language-plaintext highlighter-rouge">Single</code> still can produce an Error instead of an element. <code class="language-plaintext highlighter-rouge">Single</code>s are very useful for API calls, e.g., downloading an image, and the 1-element or 1-error nature maps nicely to different API status codes (200 + an element or maybe a 404 + an error). This <code class="language-plaintext highlighter-rouge">Trait</code> will be one of the most common ones you will use in RxSwift.</p> <h3 id="mission-completable">“Mission: Completable”</h3> <p>Completable is Never less<br/> than Success or Not –<br/> credit – for cache or when E’er —<br/> a zero-one is sought  —</p> <h3 id="explanation-1">Explanation</h3> <p>Unlike the <code class="language-plaintext highlighter-rouge">Single</code> above, <code class="language-plaintext highlighter-rouge">Completable</code>s do not provide any elements or data. It returns either the <code class="language-plaintext highlighter-rouge">onComplete</code> or an<code class="language-plaintext highlighter-rouge">onError</code>. A <code class="language-plaintext highlighter-rouge">Completable</code> is useful when the app only cares about whether an action was done or could not be done. For instance, <code class="language-plaintext highlighter-rouge">Completable</code> is the goto <code class="language-plaintext highlighter-rouge">Trait</code> for updating caches. The app doesn’t necessarily need to know what’s in the cache, so returning an Element is overkill. All the app cares about is that the cache was successfully updated (or not). This also works for other API calls like POSTs or DELETEs where all that matters is seeing that pretty <code class="language-plaintext highlighter-rouge">200</code> status (or errors).</p> <p><code class="language-plaintext highlighter-rouge">Completable</code>s also nicely chain together with <code class="language-plaintext highlighter-rouge">.andThen</code> operators, allowing for declarative programming. Very useful in your <code class="language-plaintext highlighter-rouge">AppDelegate</code> setup methods if you need initializations or API calls performed in a specific order.</p> <h3 id="three-times-a-maybe">“Three Times A Maybe”</h3> <p>a Maybe’s yes, yes and, or no —<br/> it can Complete alone —<br/> it can complete returning One —<br/> it can own an Error — </p> <h3 id="explanation-2">Explanation</h3> <p>A <code class="language-plaintext highlighter-rouge">Maybe</code> is like a <code class="language-plaintext highlighter-rouge">Single</code> combined with a Swift <code class="language-plaintext highlighter-rouge">@discardableResult</code> or a <code class="language-plaintext highlighter-rouge">Completable</code>. <code class="language-plaintext highlighter-rouge">Maybe</code> will have one of three possibilities: an <code class="language-plaintext highlighter-rouge">onComplete</code>, a <code class="language-plaintext highlighter-rouge">success</code> with <code class="language-plaintext highlighter-rouge">T</code> element, or an <code class="language-plaintext highlighter-rouge">onError</code>. It’s used when you could want the element but not necessarily need to have an element returned. For instance, fetching a value from a cache. The <code class="language-plaintext highlighter-rouge">Maybe</code> trait is not one I used too often in my day-to-day programming. I… actually don’t think I ever used it at all myself…</p> <h3 id="a-sartre-subject">“A Sartre Subject”</h3> <p>a Subject’s an object - a middle man —<br/> the conduit between<br/> subscribed events and his down stream —<br/> to see — and then be seen —</p> <h3 id="explanation-3">Explanation</h3> <p>I haven’t yet mentioned the concept of an <code class="language-plaintext highlighter-rouge">Observer</code> in Reactive programming. It’s the receiving counterpart to the passing-event <code class="language-plaintext highlighter-rouge">Observable</code>. <code class="language-plaintext highlighter-rouge">Observers</code>, for instance, could subscribe to a <code class="language-plaintext highlighter-rouge">UIButton</code> to know when a user taps on one, so, e.g., the <code class="language-plaintext highlighter-rouge">Observer</code> would receive an <code class="language-plaintext highlighter-rouge">onTap</code> event. The <code class="language-plaintext highlighter-rouge">Observer</code> would then perform the code declared during the subscription.</p> <p>A <code class="language-plaintext highlighter-rouge">Subject</code> is both an <code class="language-plaintext highlighter-rouge">Observer</code> and an <code class="language-plaintext highlighter-rouge">Observable</code>, allowing for events to be received and then passed on to other <code class="language-plaintext highlighter-rouge">Observer</code>s which had subscribed to the <code class="language-plaintext highlighter-rouge">Subject</code>. <code class="language-plaintext highlighter-rouge">Subjects</code> are widely used and come in multiple flavors and back some of what is specific to RxCocoa (to be explained in Part 4).</p> <h2 id="onward">Onward!</h2> <p>This second part introduced you to some <code class="language-plaintext highlighter-rouge">Traits</code> of <code class="language-plaintext highlighter-rouge">Observable</code>s in Reactive programming. Next, in part 3 of this series, I will go over some more intense <code class="language-plaintext highlighter-rouge">Subject</code>s in RxSwift.</p>]]></content><author><name>Trey</name></author><category term="poetry"/><category term="rxswift"/><summary type="html"><![CDATA[In Part One of this series, I provided the mnemonic poems I used to help learn and retain the basics of Reactive programming, specifically Observables and one operator (flatMap) in RxSwift.]]></summary></entry><entry><title type="html">The Quatraits of RxSwift - Part 1</title><link href="https://3sands.github.io/blog/2023/quatraitsPart1/" rel="alternate" type="text/html" title="The Quatraits of RxSwift - Part 1"/><published>2023-09-27T00:00:00+00:00</published><updated>2023-09-27T00:00:00+00:00</updated><id>https://3sands.github.io/blog/2023/quatraitsPart1</id><content type="html" xml:base="https://3sands.github.io/blog/2023/quatraitsPart1/"><![CDATA[<p>I arrived at Grindr in January of 2022 both knowing they had an <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> tech stack and knowing that I did not know RxSwift itself.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> Never having used <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">functional reactive programming</a> (FRP) before, I had to quickly reach highway speeds if I wanted to merge any pull requests. The <a href="https://www.kodeco.com/books/rxswift-reactive-programming-with-swift/v4.0">Kodeco book</a> (née Wenderlich) on RxSwift helped immensely as did, of course, actually coding six to seven hours a day. But to truly guarantee I understood FRP’s concepts and continued to retain them, I decided to combine my triple love of poetry, puns, and programming into a mnemonic: some didactic light verse. Emily Dickinson’s ballad style was the main inspiration for the format; its flexibility, humor, and concision was ideal for my purposes.</p> <p>This blog series is not intended to teach RxSwift fully but rather should solidify familiar concepts. Part 1 will contain the very basics of FRP. Part 2 will go over traits common across Reactive specifications. Part 3 covers the different flavors of Subjects. Part 4 delves into what is specific to RxCocoa and iOS.</p> <h2 id="the-basics-of-frp">The Basics of FRP</h2> <h3 id="consider-the-observable">“Consider the Observable”</h3> <p>a data stream – a Sequence – with<br/> immutability –<br/> asynchronous events comprise<br/> Observable of T –</p> <p>to this Subscribe – receive direct<br/> data, done, or error –<br/> declared intent when you compose<br/> agnostic Operators –</p> <p>onNext provides an Element –<br/> continues on – until –<br/> onError – onCompleted – ends<br/> the stream for all –</p> <p>ensure the ended’s onDispose – <br/> its computers freed –<br/> otherwise well-architected <br/> we’ll leak – memory –</p> <h3 id="explanation">Explanation</h3> <p>In FRP, data is delivered over time downstream as a sequence of immutable Events. This concept is captured in an <code class="language-plaintext highlighter-rouge">Observable</code>. The data an <code class="language-plaintext highlighter-rouge">Observable&lt;T&gt;</code> passes down can be anything, hence the generic element T.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p> <p>Once an <code class="language-plaintext highlighter-rouge">Observable</code> has been created, the app can then subscribe to this <code class="language-plaintext highlighter-rouge">Observable</code> in order respond to a new event. These events are one of three types: an element, a complete, or an error. We also, after subscribing to the <code class="language-plaintext highlighter-rouge">Observable</code>, can perform a series of different non-mutating functional operators on the delivered data events, e.g., <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">reduce</code>. Ideally, providing the series of operators at the call site results in future engineers knowing what is happening to the data (the “declaring intent”), but one should still leave a comment explaining Why the operations are being done to avoid potential misinferences.</p> <p>The subscription to an <code class="language-plaintext highlighter-rouge">Observable</code> will receive zero to many <code class="language-plaintext highlighter-rouge">T</code> elements during its lifetime and will continue to perform the operators we provided to it until one of three possibilites occur: the <code class="language-plaintext highlighter-rouge">Observable</code> returns an error, the <code class="language-plaintext highlighter-rouge">Observable</code> returns a complete, or the subscription’s <code class="language-plaintext highlighter-rouge">DisposeBag</code> is emptied. Upon the first two of these, the subscription (and any others which subscribed to that same <code class="language-plaintext highlighter-rouge">Observable</code>) will no longer respond to any further elements provided. Emptying an instance of a <code class="language-plaintext highlighter-rouge">DisposeBag</code> will only dispose of the subscriptions that have been added to that instance.</p> <p>Every subscription must be added to a <code class="language-plaintext highlighter-rouge">DisposeBag</code> for garbage collection and lifecycle purposes.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> If a subscription isn’t properly disposed, then the observable objects and the downstream subscriptions will remain in memory and leak. Take a look at the memory graph in XCode after not including a <code class="language-plaintext highlighter-rouge">DisposeBag</code> to see for yourself.</p> <h2 id="one-operator">One operator</h2> <h3 id="arizona-lipton-earl-grey">“Arizona-Lipton-Earl Grey”</h3> <p>source different streams – and bottle yours –<br/> in it the blending new –<br/> mixed Teas taste flat – Mapped all to One —<br/> but take it— and make do –</p> <h3 id="explanation-1">Explanation</h3> <p>This poem is the first one where allegorical imagery and wordplay are key to the mnemonic.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> The <code class="language-plaintext highlighter-rouge">flatMap</code> operator combines one or multiple data streams (the different flavors of <code class="language-plaintext highlighter-rouge">T</code>eas) into a single new <code class="language-plaintext highlighter-rouge">Observable</code> of a different data type altogether (the “bottle yours”) . <code class="language-plaintext highlighter-rouge">.flatMap</code> keeps the same subscription whenever new <code class="language-plaintext highlighter-rouge">onNext</code> data arrives, unlike <code class="language-plaintext highlighter-rouge">flatMapLatest</code> which disposes first. <code class="language-plaintext highlighter-rouge">.map</code> changes the data but doesn’t create a new <code class="language-plaintext highlighter-rouge">Observable</code>.</p> <h2 id="onward">Onward!</h2> <p>This first post introduced you to the basic concept of an <code class="language-plaintext highlighter-rouge">Observable</code> as well as one of its most used operators, <code class="language-plaintext highlighter-rouge">.flatMap</code>. Next, in <a href="/blog/2023/quatraitsPart2/">Part Two</a> of this series, I will go over some Traits that all Reactive specifications use.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>My team also knew this about me going in – one should be forthright with what they don’t know in an interview. Learning new tech and reading docs is a coding constant and shouldn’t necessarily be a hiring red flag. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>Realizing “Observable of T” and “immutability” both rhymed and had identical meter was the inspiration behind the poems. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p>While not strictly true that EVERY subscription needs a <code class="language-plaintext highlighter-rouge">DisposeBag</code> (e.g., a one-and-done autocompleting subscription), my personal preference is to still add to the <code class="language-plaintext highlighter-rouge">DisposeBag</code> and avoid the ugly ambiguity of <code class="language-plaintext highlighter-rouge">_ = observable.subscribe()</code> in the code. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:4" role="doc-endnote"> <p>I call poems like these Object-Oriented Poetry. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Trey</name></author><category term="poetry"/><category term="rxswift"/><summary type="html"><![CDATA[I arrived at Grindr in January of 2022 both knowing they had an RxSwift tech stack and knowing that I did not know RxSwift itself.1 Never having used functional reactive programming (FRP) before, I had to quickly reach highway speeds if I wanted to merge any pull requests. The Kodeco book (née Wenderlich) on RxSwift helped immensely as did, of course, actually coding six to seven hours a day. But to truly guarantee I understood FRP’s concepts and continued to retain them, I decided to combine my triple love of poetry, puns, and programming into a mnemonic: some didactic light verse. Emily Dickinson’s ballad style was the main inspiration for the format; its flexibility, humor, and concision was ideal for my purposes. My team also knew this about me going in – one should be forthright with what they don’t know in an interview. Learning new tech and reading docs is a coding constant and shouldn’t necessarily be a hiring red flag. &#8617;]]></summary></entry></feed>